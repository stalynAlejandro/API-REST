1)
    <link rel='manifest' href='manifest.json'>
    # Esta línea es muy importante, sirve para definir en json como se van a ver algunos elementos en un dipositivo móvil.
    # Elementos como el nombre de la app, la descripción, iconos (fuente de imágenes, tipos, tamaños..), el ´theme´ y el color de fondo. 


    <meta name='mobile-web-app-capable' content='yes'>
    # Con esta línea le estamos diciendo al explorador que está web, es capaz de mostrar contenido para móviles. 

    <meta name='apple-mobile-web-app-capable' content='yes'>
    # Esta linea es la misma que la anterior, pero también para los dispositivos apple

    <meta name='application-name' content='Air Horner'>
    <meta name='apple-mobile-web-app-status-bar-style' content='black'>
    <meta name='apple-mobile-web-app-title' content='Air Horner'>
    # Estas tres líneas también dan algunos detalles de la app, como el nombre que es 'Air Horner', que la barra de estado (la que está arriba y indica la batería, la hora, etc..) va a ser oscura. 

    <link rel='icon' sizes='192x192' href='/images/touch/android-launchericon-192-192.png'>
    <link rel='apple-touch-icon'  href='/images/touch/android-launchericon-192-192.png'>
    # Se definen como van a ser los iconos que sirvan para lanzar nuestra app en nuestro móvil, la primera es para android, y la segunda para apple. 


2)

self.addEventListener('install', e => {
  e.waitUntil(
    caches.open(cacheName).then(cache => {
      return cache.addAll([
        `/`,
        `/index.html`,
        `/styles/main.css`,
        `/scripts/main.min.js`,
        `/scripts/comlink.global.js`,
        `/scripts/messagechanneladapter.global.js`,
        `/scripts/pwacompat.min.js`,
        `/sounds/airhorn.mp3`
      ])
          .then(() => self.skipWaiting());
    })
  );
});

# Se está instalando el service worker. Se define un callback para el evento instalación ('install').
# Primero abre la caché ('open'), espera a almacenar los elementos en la caché ('cache.addAll(..)'). 
# Y finalmente deja de esperar ('skipWaiting()') después de que los elementos estén en la caché.



self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open(cacheName)
      .then(cache => cache.match(event.request, {ignoreSearch: true}))
      .then(response => {
      return response || fetch(event.request);
    })
  );
});

# Una vez instalado el service worker, se quiere responder a los eventos fetch que nos llegan. 
# Luego de detectar el evento fetch abre la cache ('caches.open'), se usa pasa una promesa cache.match()
# donde el evento detectado se pasa como principal argumento, este método examinará la solicitud y buscará
# resultados en la cache creade por el service worker. En este caso ignoará la búsquedad, según el segundo argumento. 
# Por último si encuentra un resultado dentro de la caché lo enviará, en caso contrario enviará el resultado de 
# una llamada a fetch que solicita datos a la red. 